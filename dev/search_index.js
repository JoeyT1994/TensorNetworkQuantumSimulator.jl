var documenterSearchIndex = {"docs":
[{"location":"#TensorNetworkQuantumSimulator","page":"Home","title":"TensorNetworkQuantumSimulator","text":"Documentation for TensorNetworkQuantumSimulator.\n\n","category":"section"},{"location":"#Base.truncate-Tuple{TensorNetworkState}","page":"Home","title":"Base.truncate","text":"truncate(tns::TensorNetworkState; alg = default_truncate_alg(tns), kwargs...)\nTruncate the virtual indexes of tensors in the given `TensorNetworkState` `tns` using the specified algorithm `alg`.\n\nArguments\n- `tns::TensorNetworkState`: The tensor network state to be truncated.\nKeyword Arguments\n- `alg`: The contraction algorithm to use for truncation. \n    Supported contraction algorithms include:\n    - `\"bp\"`: Belief propagation-based truncation (works on any network, cheap but can be less accurate when loop correlations are present).\n    - `\"boundarymps\"`: Boundary MPS-based truncation. Requires `mps_bond_dimension` Kwarg. Works only on a planar network and is more expensive, but more accurate if a large mps bond dim is used).\n- `maxdim::Integer`: The maximum bond dimension to retain after truncation.\n- `cutoff::Number`: The singular value cutoff for truncation (optional).\nReturns\n- The truncated `TensorNetworkState`.\n\n\n\n\n\n","category":"method"},{"location":"#ITensors.SiteTypes.op-Tuple{ITensors.SiteTypes.OpName{:Rxxyyzz}, ITensors.SiteTypes.SiteType{S=1/2}}","page":"Home","title":"ITensors.SiteTypes.op","text":"ITensors.op(::OpName\"Rxxyyzz\", ::SiteType\"S=1/2\"; θ::Number)\n\nGate for rotation by XXYYZZ at a given angle\n\n\n\n\n\n","category":"method"},{"location":"#ITensors.SiteTypes.op-Tuple{ITensors.SiteTypes.OpName{:Rxxyy}, ITensors.SiteTypes.SiteType{S=1/2}}","page":"Home","title":"ITensors.SiteTypes.op","text":"ITensors.op(::OpName\"Rxxyy\", ::SiteType\"S=1/2\"; θ::Number)\n\nGate for rotation by XXYY at a given angle\n\n\n\n\n\n","category":"method"},{"location":"#ITensors.SiteTypes.op-Tuple{ITensors.SiteTypes.OpName{:xx_plus_yy}, ITensors.SiteTypes.SiteType{S=1/2}}","page":"Home","title":"ITensors.SiteTypes.op","text":"ITensors.op(::OpName\"xx_plus_yy\", ::SiteType\"S=1/2\"; θ::Number, β::Number)\n\nGate for rotation by XX+YY at a given angle with Rz rotations either size. Consistent with qiskit.\n\n\n\n\n\n","category":"method"},{"location":"#ITensors.inner-Tuple{TensorNetworkState, TensorNetworkState}","page":"Home","title":"ITensors.inner","text":"inner(ψ::TensorNetworkState, ϕ::TensorNetworkState; alg, kwargs...)\n\nCompute the inner product between two different TensorNetworkStates using the specified algorithm.\nIf you want the norm_squared of a tensornetwork state ψ, use `norm_sqr(ψ; alg, kwargs...)` instead.\nThe two states should have the same graph structure and physical indices on each site.\n\n# Arguments\n- `ψ::TensorNetworkState`: The first tensor network state.\n- `ϕ::TensorNetworkState`: The second tensor network state.\n\n# Keyword Arguments\n- `alg`: The algorithm to use for the inner product calculation. Options include:\n    - `\"exact\"`: Exact contraction of the tensor network.\n    - `\"bp\"`: Belief propagation approximation.\n    - `\"boundarymps\"`: Boundary MPS approximation (requires `mps_bond_dimension`).\n    - `\"loopcorrections\"`: Loop corrections to belief propagation.\n- Extra kwargs for `alg = \"boundarymps\"`:\n    - `mps_bond_dimension::Integer`: The bond dimension for the boundary MPS approximation.\n    - `partition_by`: How to partition the graph for boundary MPS (default is `\"row\"`).\n    - `cache_update_kwargs`: Additional keyword arguments for updating the cache.\n- Extra kwargs for `alg = \"bp\"` or `\"loopcorrections\"`:\n    - `cache_update_kwargs`: Additional keyword arguments for updating the cache.\n    - `max_configuration_size`: Maximum configuration size for loop corrections (only for `\"loopcorrections\"`).\n\n# Returns\n- The computed inner product as a scalar value.\n\n# Example\n```julia\ns = siteinds(\"S=1/2\", g)\nψ = random_tensornetworkstate(ComplexF32, g, s; bond_dimension = 4)\nϕ = random_tensornetworkstate(ComplexF32, g, s; bond_dimension = 4)\n\n# Exact inner product\nip_exact = ITensors.inner(ψ, ϕ; alg = \"exact\")\n\n# Belief propagation inner product\nip_bp = ITensors.inner(ψ, ϕ; alg = \"bp\")\n\n# Boundary MPS inner product with bond dimension 10\nip_bmps = ITensors.inner(ψ, ϕ; alg = \"boundarymps\", mps_bond_dimension = 10)\n```\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.normalize-Tuple{TensorNetworkState}","page":"Home","title":"LinearAlgebra.normalize","text":"normalize(tns::TensorNetworkState; alg, kwargs...)\nNormalize a `TensorNetworkState` using the specified algorithm.\n\n# Arguments\n- `tns::TensorNetworkState`: The tensor network state to be normalized.\n\n# Keyword Arguments\n- `alg`: The algorithm to use for normalization. Currently, only `\"bp\"` is supported.\n\n# Returns\n- The normalized `tns::TensorNetworkState` such that `norm_sqr(tns; alg) = 1`.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.add-Tuple{AbstractTensorNetwork, AbstractTensorNetwork}","page":"Home","title":"TensorNetworkQuantumSimulator.add","text":"Add two tensornetworks together. The network structures need to be have the same graph structure\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.apply_gates-Tuple{Vector, TensorNetworkState}","page":"Home","title":"TensorNetworkQuantumSimulator.apply_gates","text":"apply_gates(circuit::Vector, ψ::Union{TensorNetworkState, BeliefPropagationCache}; bp_update_kwargs = default_bp_update_kwargs(ψ), kwargs...)\nApply a sequence of gates, via simple update, to a `TensorNetworkState` or a `BeliefPropagationCache`` wrapping a `TensorNetworkState`` using Belief Propagation to update the environment.\n# Arguments\n- `circuit::Vector`: A vector of tuples where each tuple contains a gate (as an `ITensor`) and the vertices it acts on.\n- `ψ::TensorNetworkState`: The tensor network state to which the gates will be applied.\n- `bp_update_kwargs`: Keyword arguments for updating the Belief Propagation cache between gates (reasonable defaults are set).\n- `apply_kwargs`: Keyword arguments for the gate application. These include options like `maxdim` and `cutoff` for bond dimension truncation during gate application.\n# Returns\n- A tuple containing the updated `TensorNetworkState` or `BeliefPropagationCache` and a vector of truncation errors for each gate application.\n\nend\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.expect-Tuple{Union{BeliefPropagationCache, BoundaryMPSCache, TensorNetworkState}, Any}","page":"Home","title":"TensorNetworkQuantumSimulator.expect","text":"expect(ψ, observable; alg=\"exact\", kwargs...) -> Number or Vector{Number}\n\nArguments:\n\nψ::Union{TensorNetworkState, BeliefPropagationCache, BoundaryMPSCache}: The TensorNetworkState (TNS) or cache wrapping the TNS to measure the observable(s) on.\nobservable::Union{Tuple, Vector{<:Tuple}}: The observable(s) to measure. Should be a tuple or vector of tuples of the form (ops, vertices, coeff=1).\nalg::Union{String, Nothing}: The algorithm to use for the measurement. \n\nKeyword Arguments:\n\ncache_update_kwargs...: Keyword arguments passed to the update function when using bp or boundarymps algorithms.\n\nReturns:\n\nA single number if measuring one observable, or a vector of numbers if measuring multiple observables.\n\nSupported algorithms:\n\n\"exact\": Exact contraction of the tensor network.\n\"bp\": Belief propagation approximation.\n\"boundarymps\": Boundary MPS approximation (requires mps_bond_dimension kwarg).\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.fidelity-Tuple{Vector{ITensors.ITensor}, Vararg{ITensors.ITensor, 5}}","page":"Home","title":"TensorNetworkQuantumSimulator.fidelity","text":"Calculate the overlap of the gate acting on the previous p and q versus the new p and q in the presence of environments. This is the cost function that optimisepq will minimise\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.full_update-Tuple{ITensors.ITensor, TensorNetworkState, Any}","page":"Home","title":"TensorNetworkQuantumSimulator.full_update","text":"Full Update of two tensors v1 and v2 in the presence of environments envs under the action of a two site gate o.\nMore general than a simple_upddate (allows for more accurate non-BP environments), but that comes at a higher computational cost depending\non the dimensions of the environment tensors involved.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.heavy_hexagonal_lattice-Tuple{Int64, Int64}","page":"Home","title":"TensorNetworkQuantumSimulator.heavy_hexagonal_lattice","text":"heavy_hexagonal_lattice(nx::Int64, ny::Int64)\n\nCreate heavy-hexagonal lattice geometry with nx columns of heavy-hexes and ny rows\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.identitytensornetworkstate","page":"Home","title":"TensorNetworkQuantumSimulator.identitytensornetworkstate","text":"identitytensornetwork(tninds::IndsNetwork)\n\nTensor network (in Heisenberg picture) for identity matrix on given IndsNetwork\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkQuantumSimulator.lieb_lattice-Tuple{Int64, Int64}","page":"Home","title":"TensorNetworkQuantumSimulator.lieb_lattice","text":"lieb_lattice(nx::Int64, ny::Int64; periodic = false)\n\nCreate Lieb lattice geometry with nx columns of decorated squared and ny rows\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.optimise_p_q-Tuple{ITensors.ITensor, ITensors.ITensor, Vector{ITensors.ITensor}, ITensors.ITensor}","page":"Home","title":"TensorNetworkQuantumSimulator.optimise_p_q","text":"Do Full Update Sweeping, Optimising the tensors p and q in the presence of the environments envs, Specifically this functions find the pcur and qcur which optimise envsgatepqdag(prime(pcur))*dag(prime(qcur))\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.paulirotationmatrix-Tuple{Any, Any}","page":"Home","title":"TensorNetworkQuantumSimulator.paulirotationmatrix","text":"paulirotationmatrix(generator, θ)\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.paulitensornetworkstate","page":"Home","title":"TensorNetworkQuantumSimulator.paulitensornetworkstate","text":"topaulitensornetwork(op, g::NamedGraph)\n\nTensor network (in Heisenberg picture). Function should map vertices of the graph to pauli strings.\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkQuantumSimulator.random_tensornetworkstate","page":"Home","title":"TensorNetworkQuantumSimulator.random_tensornetworkstate","text":"random_tensornetworkstate(eltype, g::AbstractGraph, siteinds::Dictionary; bond_dimension::Integer = 1)\nGenerate a random TensorNetworkState on graph `g` with local state indices given by the dictionary `siteinds`.\n\nArguments:\n- `eltype`: (Optional) The number type of the tensor elements (e.g. Float64, ComplexF32). Default is Float64.\n- `g::AbstractGraph`: The underlying graph of the tensor network.\n- `siteinds::Dictionary`: A dictionary mapping vertices to ITensor indices representing the local states. Defaults to spin 1/2.\n- `bond_dimension::Integer`: The bond dimension of the virtual indices connecting neighboring tensors (default is 1).\n\nReturns:\n- A `TensorNetworkState` object representing the random tensor network state.\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkQuantumSimulator.random_tensornetworkstate-2","page":"Home","title":"TensorNetworkQuantumSimulator.random_tensornetworkstate","text":"random_tensornetworkstate(eltype, g::AbstractGraph, sitetype::String, d::Integer = site_dimension(sitetype); bond_dimension::Integer = 1)\nGenerate a random TensorNetworkState on graph `g` with local state indices generated from the `sitetype` string (e.g. \"S=1/2\", \"Pauli\") and the local dimension `d` (default is 2 for \"S=1/2\", 4 for Pauli etc).\n\nArguments:\n- `eltype`: (Optional) The number type of the tensor elements (e.g. Float64, ComplexF32). Default is Float64.\n- `g::AbstractGraph`: The underlying graph of the tensor network.\n- `sitetype::String`: A string representing the type of local site (e.g. \"S=1/2\", \"Pauli\").\n- `d::Integer`: The local dimension of the site (default is determined by `sitetype`).\n- `bond_dimension::Integer`: The bond dimension of the virtual indices connecting neighboring tensors (default is 1).\nReturns:\n- A `TensorNetworkState` object representing the random tensor network state.\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkQuantumSimulator.reduced_density_matrix-Tuple{Union{BeliefPropagationCache, BoundaryMPSCache, TensorNetworkState}, Any}","page":"Home","title":"TensorNetworkQuantumSimulator.reduced_density_matrix","text":"reduced_density_matrix(ψ::Union{TensorNetworkState, BeliefPropagationCache, BoundaryMPSCache}, verts; alg::Union{String, Nothing} = nothing, kwargs...)\nCompute the reduced density matrix on the vertices `verts` of the tensor network state `ψ`.\n\n# Arguments\n- `ψ::Union{TensorNetworkState, BeliefPropagationCache, BoundaryMPSCache}`: The tensor network state or its associated cache.\n- `verts`: The vertices over which to compute the reduced density matrix. Can be a single vertex, or a collection of vertices.\n- `alg::Union{String, Nothing}`: (Optional) The contraction algorithm to use. If not provided, defaults based on the type of `ψ`. Supported algorithms are \"exact\", \"bp\", and \"boundarymps\".\n# Keyword Arguments\n- `kwargs...`: Additional keyword arguments specific to the chosen algorithm.\n- `normalize::Bool = true`: Whether to normalize the reduced density matrix so that its trace is 1.\n# Returns\n- An `ITensor` representing the reduced density matrix on the specified vertices.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.safe_eigen-Tuple{ITensors.ITensor, Vararg{Any}}","page":"Home","title":"TensorNetworkQuantumSimulator.safe_eigen","text":"safe_eigen(m::ITensor, args...; kwargs...)\nA wrapper around ITensors.eigen that ensures eigen computations are done in Float64/ComplexF64 precision on CPU for better numerical stability.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.sample-Tuple{TensorNetworkState, Integer}","page":"Home","title":"TensorNetworkQuantumSimulator.sample","text":"sample(\n    ψ::TensorNetworkState,\n    nsamples::Integer;\n    projected_message_rank::Integer,\n    norm_message_rank::Integer,\n    norm_message_update_kwargs=(; niters = _default_boundarymps_update_niters, tolerance = _default_boundarymps_update_tolerance),\n    projected_message_update_kwargs = (;cutoff = _default_boundarymps_update_cutoff, maxdim = projected_message_rank),\n    partition_by = \"Row\",\n    kwargs...,\n)\n\nTake nsamples bitstrings, based on the square of the coefficients of the vector defined by a 2D open boundary tensornetwork.\n\nArguments\n\nψ::TensorNetworkState: The tensornetwork state to sample from.\nnsamples::Integer: Number of samples to draw.\n\nKeyword Arguments\n\nalg ::String: The algorithm to use for sampling (\"boundarymps\" and \"bp\" currently supported).\n\nSupported kwargs for alg = \"boundarymps\":     - projected_mps_bond_dimension::Int: Bond dimension of the projected boundary MPS messages used during contraction of the projected state <x|ψ>.     - norm_mps_bond_dimension::Int: Bond dimension of the boundary MPS messages used to contract <ψ|ψ>.     - norm_message_update_kwargs: Keyword arguments for updating the norm boundary MPS messages.     - projected_message_update_kwargs: Keyword arguments for updating the projected boundary MPS messages.     - partition_by: How to partition the graph for boundary MPS (default is \"Row\"). Supported kwargs for alg = \"bp\":     - bpupdatekwargs: \n\nReturns\n\nA vector of bitstrings sampled from the probability distribution defined by as a dictionary mapping each vertex to a configuration (0...d).\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.sample_certified-Tuple{TensorNetworkState, Int64}","page":"Home","title":"TensorNetworkQuantumSimulator.sample_certified","text":"sample_certified(\n    ψ::TensorNetworkState,\n    nsamples::Integer;\n    projected_message_rank::Integer,\n    norm_message_rank::Integer,\n    norm_message_update_kwargs=(; niters = _default_boundarymps_update_niters, tolerance = _default_boundarymps_update_tolerance),\n    projected_message_update_kwargs = (;cutoff = _default_boundarymps_update_cutoff, maxdim = projected_message_rank),\n    partition_by = \"Row\",\n    kwargs...,\n)\n\nTake nsamples bitstrings from a 2D open boundary tensornetwork. The samples are drawn from x~q(x) and for each sample an independent contraction of <x|ψ> is performed to get a measure of p(x)/q(x).\n\nArguments\n\nψ::TensorNetworkState: The tensornetwork state to sample from.\nnsamples::Integer: Number of samples to draw.\n\nKeyword Arguments\n\nalg ::String: The algorithm to use for sampling (\"boundarymps\" is the only option currently supported).\n\nSupported kwargs for alg = \"boundarymps\":     - projected_mps_bond_dimension::Int: Bond dimension of the projected boundary MPS messages used during contraction of the projected state <x|ψ>.     - norm_mps_bond_dimension::Int: Bond dimension of the boundary MPS messages used to contract <ψ|ψ>.     - certification_mps_bond_dimension::Int: Bond dimension of the boundary MPS messages used to contract <x|ψ> for certification.     - norm_message_update_kwargs: Keyword arguments for updating the norm boundary MPS messages.     - projected_message_update_kwargs: Keyword arguments for updating the projected boundary MPS messages.     - partition_by: How to partition the graph for boundary MPS (default is \"Row\").\n\nReturns\n\nVector of NamedTuples. Each NamedTuple contains:\n\npoverq: Approximate value of p(x)/q(x) for the sampled bitstring x.\nbitstring: The sampled bitstring as a dictionary mapping each vertex to a configuration (0...d).\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.sample_directly_certified-Tuple{TensorNetworkState, Integer}","page":"Home","title":"TensorNetworkQuantumSimulator.sample_directly_certified","text":"sample_directly_certified(\n    ψ::TensorNetworkState,\n    nsamples::Integer;\n    projected_message_rank::Integer,\n    norm_message_rank::Integer,\n    norm_message_update_kwargs=(; niters = _default_boundarymps_update_niters, tolerance = _default_boundarymps_update_tolerance),\n    projected_message_update_kwargs = (;cutoff = _default_boundarymps_update_cutoff, maxdim = projected_message_rank),\n    partition_by = \"Row\",\n    kwargs...,\n)\n\nTake nsamples bitstrings from a 2D open boundary tensornetwork. The samples are drawn from x~q(x) and for each sample <x|ψ> is calculated \"on-the-fly\" to get a measure of p(x)/q(x).\n\nArguments\n\nψ::TensorNetworkState: The tensornetwork state to sample from.\nnsamples::Integer: Number of samples to draw.\n\nKeyword Arguments\n\nalg ::String: The algorithm to use for sampling (\"boundarymps\" is the only one currently supported).\n\nSupported kwargs for alg = \"boundarymps\":     - projected_mps_bond_dimension::Int: Bond dimension of the projected boundary MPS messages used during contraction of the projected state <x|ψ>.     - norm_mps_bond_dimension::Int: Bond dimension of the boundary MPS messages used to contract <ψ|ψ>.     - norm_message_update_kwargs: Keyword arguments for updating the norm boundary MPS messages.     - projected_message_update_kwargs: Keyword arguments for updating the projected boundary MPS messages.     - partition_by: How to partition the graph for boundary MPS (default is \"Row\").\n\nReturns\n\nVector of NamedTuples. Each NamedTuple contains:\n\npoverq: Approximate value of p(x)/q(x) for the sampled bitstring x.\nlogq: Log probability of drawing the bitstring.\nbitstring: The sampled bitstring as a dictionary mapping each vertex to a configuration (0...d).\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.simple_update-Tuple{ITensors.ITensor, Any, Any}","page":"Home","title":"TensorNetworkQuantumSimulator.simple_update","text":"simpleupdate(o, ψ, v⃗; envs, normalizetensors = true, applykwargs...)     Simple Update of one or two tensors v⃗ in the presence of factorized environments envs under the action of a one- or two-site gate o.     This is a computationally cheaper but less accurate alternative to fullupdate. It is exact if no truncation is performed.     # Arguments     - o::ITensor: The gate to be applied.     - ψ::TensorNetworkState: The tensor network state on which the gate is applied.     - v⃗::Vector{Int}: The vertices of  ψ where the gate is applied.     - envs::Vector{ITensor}: The factorized environment tensors associated with the tensors in v⃗.     - normalize_tensors::Bool: Whether to normalize the updated tensors. Default is true.     - apply_kwargs...: Additional keyword arguments passed to the SVD factorization.\n\n# Returns\n- `updated_tensors::Vector{ITensor}`: The updated tensors after applying the gate.\n- `s_values::Union{Nothing, ITensor}`: The singular values from the SVD (if applicable).\n- `err::Number`: The truncation error from the SVD (if applicable).\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.tensornetworkstate","page":"Home","title":"TensorNetworkQuantumSimulator.tensornetworkstate","text":"tensornetworkstate(eltype, f::Function, g::AbstractGraph, siteinds::Dictionary)\nConstruct a TensorNetworkState on graph `g` where the function `f` maps vertices to local states.\nThe local states can be given as strings (e.g. \"↑\", \"↓\", \"0\", \"1\", \"I\", \"X\", \"Y\", \"Z\") or as vectors of numbers (e.g. [1,0], [0,1], [1/sqrt(2), 1/sqrt(2)]).\n\nArguments:\n- `eltype`: (Optional) The number type of the tensor elements (e.g. Float64, ComplexF32). Default is Float64.\n- `f::Function`: A function mapping vertices of the graph to local states.\n- `g::AbstractGraph`: The underlying graph of the tensor network.\n- `siteinds::Dictionary`: A dictionary mapping vertices to ITensor indices representing the local states. Defaults to spin 1/2.\nReturns:    \n- A `TensorNetworkState` object representing the constructed tensor network state.\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkQuantumSimulator.tensornetworkstate-2","page":"Home","title":"TensorNetworkQuantumSimulator.tensornetworkstate","text":"tensornetworkstate(eltype, f::Function, g::AbstractGraph, sitetype::String, d::Integer = site_dimension(sitetype))\nConstruct a TensorNetworkState on graph `g` where the function `f` maps vertices to local states.\nThe local states can be given as strings (e.g. \"↑\", \"↓\", \"0\", \"1\", \"I\", \"X\", \"Y\", \"Z\") or as vectors of numbers (e.g. [1,0], [0,1], [1/sqrt(2), 1/sqrt(2)]).\n\nArguments:\n- `eltype`: (Optional) The number type of the tensor elements (e.g. Float64, ComplexF32). Default is Float64.\n- `f::Function`: A function mapping vertices of the graph to local states.\n- `g::AbstractGraph`: The underlying graph of the tensor network.\n- `sitetype::String`: A string representing the type of local site (e.g. \"S=1/2\", \"Pauli\").\n- `d::Integer`: The local dimension of the site (default is determined by `sitetype`).\n\nReturns:\n- A `TensorNetworkState` object representing the constructed tensor network state.\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkQuantumSimulator.update-Tuple{NDTensors.BackendSelection.Algorithm{:bp}, TensorNetworkQuantumSimulator.AbstractBeliefPropagationCache}","page":"Home","title":"TensorNetworkQuantumSimulator.update","text":"More generic interface for update, with default params\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.update_iteration!-Tuple{NDTensors.BackendSelection.Algorithm{:bp}, TensorNetworkQuantumSimulator.AbstractBeliefPropagationCache, Vector}","page":"Home","title":"TensorNetworkQuantumSimulator.update_iteration!","text":"Do a sequential update of the message tensors on edges\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.zerostate","page":"Home","title":"TensorNetworkQuantumSimulator.zerostate","text":"zerostate(g::NamedGraph)\n\nTensor network for vacuum state on given graph, i.e all spins up\n\n\n\n\n\n","category":"function"}]
}
